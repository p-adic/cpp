#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/AffineSpace/Distance/Linear/a_Body.hpp"
#else
TE <TY INT>INT Distance(CO INT& x0,CO set<INT>& x1){AS(!x1.empty());auto IT = x1.lower_bound(x0);if(IT == x1.EN()){RE x0 - *(x1.rBE());}INT AN = *IT - x0;RE IT == x1.BE()?AN:min(AN,x0 - *(--IT));}TE <TY INT>VE<set<pair<INT,int>>> Multipoint_Distance(CO VE<INT>& x0,CO VE<INT>& x1,CRI LE){CO int SZ0 = x0.SZ();CO int SZ1 = x1.SZ();CO int SZ = SZ0 + SZ1;VE<pair<INT,int>> x(SZ);for(int i = 0;i < SZ0;i++){x[i]={x0[i],i};}for(int i = 0;i < SZ1;i++){x[i + SZ0]={x1[i],i + SZ0};}sort(x.BE(),x.EN());VE<set<pair<INT,int>>> AN(SZ0);set<pair<INT,int>> temp{};INT d_init = x.back();for(int n = 0;n < SZ;n++){auto&[xn,i]= x[n];if(i < SZ0){CO INT dx = xn - d_init;auto& AN_i = AN[i];for(auto& d:temp){AN_i.insert({d.first + dx,d.second});}}else{temp.insert({(d_init = min(d_init,xn))- xn,i - SZ0});if(int(temp.SZ())> LE){temp.erase(--(temp.EN()));}}}d_init = x.front();for(int n = SZ - 1;n >= 0;n--){auto&[xn,i]= x[n];if(i < SZ0){CO INT dx = d_init - xn;auto& AN_i = AN[i];for(auto& d:temp){AN_i.insert({d.first + dx,d.second});if(AN_i.SZ()> LE){AN_i.erase(--(AN_i.EN()));}}}else{temp.insert({xn -(d_init = max(d_init,xn)),i - SZ0});if(int(temp.SZ())> LE){temp.erase(--(temp.EN()));}}}RE AN;}
#endif
