// ../../../compress.txt‚ðæ‚É“\‚éB

#define BELLMAN_FORD_BODY(INITIALISE_PREV,SET_PREV)CO U& zero = m_M.Zero();CO U& infty = TH->Infty();AS(zero < infty);CRI SZ = m_G.SZ();auto&& i_start = m_G.Enumeration_inv(t_start);AS(0 <= i_start && i_start < SZ);VE<bool> found(SZ);VE<U> weight(SZ,infty);found[i_start]= true;weight[i_start]= 0;INITIALISE_PREV;for(int LE = 0;LE < SZ;LE++){for(int i = 0;i < SZ;i++){if(found[i]){CO U& weight_i = weight[i];AS(weight_i != infty);auto&& edge_i = m_G.Edge(m_G.Enumeration(i));for(auto IT = edge_i.BE(),EN = edge_i.EN();IT != EN;IT++){auto&& j = m_G.Enumeration_inv(IT->first);CO U& edge_ij = IT->second;U temp = m_M.Sum(weight_i,edge_ij);U& weight_j = weight[j];if(weight_j > temp){found[j]= true;weight_j = MO(temp);SET_PREV;}}}}}bool valid = true;for(int i = 0;i < SZ && valid;i++){if(found[i]){CO U& weight_i = weight[i];auto&& edge_i = m_G.Edge(m_G.Enumeration(i));for(auto IT = edge_i.begin(),EN = edge_i.EN();IT != EN;IT++){auto&& j = m_G.Enumeration_inv(IT->first);CO U& edge_ij = IT->second;U& weight_j = weight[j];CO U temp = m_M.Sum(weight_i,edge_ij);if(weight_j > temp){valid = false;break;}}}}
TE <TY GRAPH,TY MONOID,TY U>CL AbstractBellmanFord:PU PointedSet<U>{PU:GRAPH& m_G;MONOID m_M;IN AbstractBellmanFord(GRAPH& G,MONOID M,CO U& infty);tuple<bool,VE<U>> GetDistance(CO inner_t<GRAPH>& t_start);TE <TE <TY...> TY V> tuple<bool,VE<U>,VE<LI<inner_t<GRAPH>>>> GetPath(CO inner_t<GRAPH>& t_start,CO V<inner_t<GRAPH>>& t_finals);tuple<bool,VE<U>,VE<LI<inner_t<GRAPH>>>> GetPath(CO inner_t<GRAPH>& t_start);};TE <TY GRAPH>CL BellmanFord:PU AbstractBellmanFord<GRAPH,AdditiveMonoid<>,ll>{PU:IN BellmanFord(GRAPH& G);};
TE <TY GRAPH,TY MONOID,TY U> IN AbstractBellmanFord<GRAPH,MONOID,U>::AbstractBellmanFord(GRAPH& G,MONOID M,CO U& infty):PointedSet<U>(infty),m_G(G),m_M(MO(M)){ST_AS(! is_same_v<U,int>);}TE <TY GRAPH> IN BellmanFord<GRAPH>::BellmanFord(GRAPH& G):AbstractBellmanFord<GRAPH,AdditiveMonoid<>,ll>(G,AdditiveMonoid<>(),4611686018427387904){}TE <TY GRAPH,TY MONOID,TY U>tuple<bool,VE<U>> AbstractBellmanFord<GRAPH,MONOID,U>::GetDistance(CO inner_t<GRAPH>& t_start){BELLMAN_FORD_BODY(,);m_G.Reset();RE{valid,MO(weight)};}TE <TY GRAPH,TY MONOID,TY U> TE <TE <TY...> TY V>tuple<bool,VE<U>,VE<LI<inner_t<GRAPH>>>> AbstractBellmanFord<GRAPH,MONOID,U>::GetPath(CO inner_t<GRAPH>& t_start,CO V<inner_t<GRAPH>>& t_finals){BELLMAN_FORD_BODY(VE<int> prev(SZ),prev[j]= i);VE<LI<inner_t<GRAPH>>> path{};if(valid){CO int path_SZ = t_finals.SZ();path.reserve(path_SZ);for(auto IT = t_finals.begin(),EN = t_finals.EN();IT != EN;IT++){LI<inner_t<GRAPH>> path_j{};CO inner_t<GRAPH>& t_final = *IT;path_j.push_back(t_final);int i = m_G.Enumeration_inv(t_final);if(found[i]){WH(i != i_start){i = prev[i];path_j.push_front(m_G.Enumeration(i));}}path.push_back(path_j);}}m_G.Reset();RE{valid,MO(weight),MO(path)};}TE <TY GRAPH,TY MONOID,TY U>tuple<bool,VE<U>,VE<LI<inner_t<GRAPH>>>> AbstractBellmanFord<GRAPH,MONOID,U>::GetPath(CO inner_t<GRAPH>& t_start){CRI SZ = m_G.SZ();VE<inner_t<GRAPH>> t_finals(SZ);for(int i = 0;i < SZ;i++){t_finals[i]= i;}RE GetPath(t_start,t_finals);}

#define DIJKSTRA_BODY(INITIALISE_PREV,CHECK_FINAL,SET_PREV)CO U& zero = m_M.Zero();CO U& infty = TH->Infty();AS(zero < infty);CRI SZ = m_G.SZ();auto&& i_start = m_G.Enumeration_inv(t_start);AS(0 <= i_start && i_start < SZ);set<pair<U,int>> vertex{};VE<bool> found(SZ);VE<U> weight(SZ,infty);vertex.insert(pair<U,int>(weight[i_start]= zero,i_start));INITIALISE_PREV;WH(! vertex.empty()){auto begin = vertex.begin();auto[weight_i,i]= *begin;CHECK_FINAL;found[i]= true;vertex.erase(begin);auto&& edge_i = m_G.Edge(m_G.Enumeration(i));LI<pair<U,int>> changed_vertex{};for(auto IT = edge_i.begin(),EN = edge_i.EN();IT != EN;IT++){auto&& j = m_G.Enumeration_inv(IT->first);if(!found[j]){CO U& edge_ij = IT->second;U temp = m_M.Sum(weight_i,edge_ij);AS(!(temp < edge_ij)&& temp < infty);U& weight_j = weight[j];if(weight_j > temp){if(weight_j != infty){vertex.erase(pair<U,int>(weight_j,j));}SET_PREV;changed_vertex.push_back(pair<U,int>(weight_j = MO(temp),j));}}}for(auto IT_changed = changed_vertex.begin(),EN_changed = changed_vertex.EN();IT_changed != EN_changed;IT_changed++){vertex.insert(*IT_changed);}}
TE <TY GRAPH,TY MONOID,TY U>CL AbstractDijkstra:PU PointedSet<U>{PU:GRAPH& m_G;MONOID m_M;IN AbstractDijkstra(GRAPH& G,MONOID M,CO U& infty);U GetDistance(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final);VE<U> GetDistance(CO inner_t<GRAPH>& t_start);pair<U,LI<inner_t<GRAPH>>> GetPath(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final);TE <TE <TY...> TY V> pair<VE<U>,VE<LI<inner_t<GRAPH>>>> GetPath(CO inner_t<GRAPH>& t_start,CO V<inner_t<GRAPH>>& t_finals);pair<VE<U>,VE<LI<inner_t<GRAPH>>>> GetPath(CO inner_t<GRAPH>& t_start);};TE <TY GRAPH>CL Dijkstra:PU AbstractDijkstra<GRAPH,AdditiveMonoid<>,ll>{PU:IN Dijkstra(GRAPH& G);};
TE <TY GRAPH,TY MONOID,TY U> IN AbstractDijkstra<GRAPH,MONOID,U>::AbstractDijkstra(GRAPH& G,MONOID M,CO U& infty):PointedSet<U>(infty),m_G(G),m_M(MO(M)){ST_AS(! is_same_v<U,int>);}TE <TY GRAPH> IN Dijkstra<GRAPH>::Dijkstra(GRAPH& G):AbstractDijkstra<GRAPH,AdditiveMonoid<>,ll>(G,AdditiveMonoid<>(),4611686018427387904){}TE <TY GRAPH,TY MONOID,TY U>U AbstractDijkstra<GRAPH,MONOID,U>::GetDistance(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final){auto&& i_final = m_G.Enumeration_inv(t_final);DIJKSTRA_BODY(,if(i == i_final){break;},);U AN{MO(weight[i_final])};m_G.Reset();RE AN;}TE <TY GRAPH,TY MONOID,TY U>VE<U> AbstractDijkstra<GRAPH,MONOID,U>::GetDistance(CO inner_t<GRAPH>& t_start){DIJKSTRA_BODY(,,);m_G.Reset();RE weight;}TE <TY GRAPH,TY MONOID,TY U>pair<U,LI<inner_t<GRAPH>>> AbstractDijkstra<GRAPH,MONOID,U>::GetPath(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final){auto&& i_final = m_G.Enumeration_inv(t_final);DIJKSTRA_BODY(VE<int> prev(SZ),if(i == i_final){break;},prev[j]= i);int i = i_final;LI<inner_t<GRAPH>> path{};path.push_back(t_final);if(found[i]){WH(i != i_start){i = prev[i];path.push_front(m_G.Enumeration(i));}}U AN{MO(weight[i_final])};m_G.Reset();RE{MO(AN),MO(path)};}TE <TY GRAPH,TY MONOID,TY U> TE <TE <TY...> TY V>pair<VE<U>,VE<LI<inner_t<GRAPH>>>> AbstractDijkstra<GRAPH,MONOID,U>::GetPath(CO inner_t<GRAPH>& t_start,CO V<inner_t<GRAPH>>& t_finals){DIJKSTRA_BODY(VE<int> prev(SZ),,prev[j]= i);CO int path_SZ = t_finals.SZ();VE<LI<inner_t<GRAPH>>> path;path.reserve(path_SZ);for(auto IT = t_finals.begin(),EN = t_finals.EN();IT != EN;IT++){LI<inner_t<GRAPH>> path_j{};CO inner_t<GRAPH>& t_final = *IT;path_j.push_back(t_final);int i = m_G.Enumeration_inv(t_final);if(found[i]){WH(i != i_start){i = prev[i];path_j.push_front(m_G.Enumeration(i));}}path.push_back(path_j);}m_G.Reset();RE{MO(weight),MO(path)};}TE <TY GRAPH,TY MONOID,TY U>pair<VE<U>,VE<LI<inner_t<GRAPH>>>> AbstractDijkstra<GRAPH,MONOID,U>::GetPath(CO inner_t<GRAPH>& t_start){CRI SZ = m_G.SZ();VE<inner_t<GRAPH>> t_finals(SZ);for(int i = 0;i < SZ;i++){t_finals[i]= i;}RE GetPath(t_start,t_finals);}

#define POTENTIALISED_DIJKSTRA_BODY(GET,WEIGHT,...)CO U& infty = TH->Infty();if(m_valid){CO U& zero = m_M.Zero();auto edge =[&](CO T& t){CO U& potential_i = m_potential[m_G.Enumeration_inv(t)];AS(potential_i < infty);auto edge_i = m_G.Edge(t);LI<pair<T,U>> AN{};for(auto IT = edge_i.begin(),EN = edge_i.EN();IT != EN;IT++){auto& e = *IT;if(m_on(e)){CO auto& v_j = get<0>(e);U& w_j = get<1>(e);CO U& potential_j = m_potential[m_G.Enumeration_inv(v_j)];AS(w_j < infty && potential_j < infty);CO U potential_j_inv = m_M.Inverse(potential_j);w_j = m_M.Sum(m_M.Sum(w_j,potential_i),potential_j_inv);AS(!(w_j < zero)&& w_j < infty);AN.push_back({v_j,MO(w_j)});}}RE AN;};auto G = m_G.GetGraph(MO(edge));AbstractDijkstra d{G,m_M,infty};auto value = d.GET;CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){auto& weight_i = WEIGHT[i];if(weight_i != infty){weight_i = m_M.Sum(weight_i,m_potential[i]);}}RE{m_valid,__VA_ARGS__};}auto edge =[&](CO T& t){auto&& edge_i = m_G.Edge(t);LI<pair<T,U>> AN{};for(auto IT = edge_i.begin(),EN = edge_i.EN();IT != EN;IT++){if(m_on(*IT)){AN.push_back({get<0>(*IT),get<1>(*IT)});}}RE AN;};auto G = m_G.GetGraph(MO(edge));AbstractBellmanFord d{G,m_M,infty};RE d.GET;
TE <TY T,TY GRAPH,TY GROUP,TY U,TY On>CL AbstractPotentialisedDijkstra:PU PointedSet<U>{PU:GRAPH& m_G;GROUP m_M;T m_t_start;bool m_valid;VE<U> m_potential;On m_on;IN AbstractPotentialisedDijkstra(GRAPH& G,GROUP M,CO T& t_start,CO U& infty,On on,CO bool& negative = true);IN AbstractPotentialisedDijkstra(GRAPH& G,GROUP M,CO T& t_start,CO U& infty,CO bool& valid,VE<U> potential,On on);IN CO bool& Valid()CO NE;IN CO VE<U>& Potential()CO NE;IN VO SetPotential(CO bool& valid,VE<U> potential);tuple<bool,VE<U>> GetDistance();TE <TY...Args> tuple<bool,VE<U>,VE<LI<T>>> GetPath(CO Args&... args);};TE <TY T,TY GRAPH,TY On>CL PotentialisedDijkstra:PU AbstractPotentialisedDijkstra<T,GRAPH,AdditiveGroup<>,ll,On>{PU:TE <TY...Args> IN PotentialisedDijkstra(GRAPH& G,CO T& t_start,Args&&... args);};
TE <TY T,TY GRAPH,TY GROUP,TY U,TY On> IN AbstractPotentialisedDijkstra<T,GRAPH,GROUP,U,On>::AbstractPotentialisedDijkstra(GRAPH& G,GROUP M,CO T& t_start,CO U& infty,On on,CO bool& negative):AbstractPotentialisedDijkstra(G,MO(M),t_start,infty,true,VE<U>(),MO(on)){if(negative){auto edge =[&](CRI t){auto&& edge_i = m_G.Edge(t);LI<pair<T,U>> AN{};for(auto IT = edge_i.begin(),EN = edge_i.EN();IT != EN;IT++){CO auto& e = *IT;AN.push_back({get<0>(e),get<1>(e)});}RE AN;};auto G_full = m_G.GetGraph(MO(edge));AbstractBellmanFord bf{G_full,m_M,infty};auto[valid,potential]= bf.GetDistance(m_t_start);m_valid = valid;m_potential = MO(potential);}else{m_potential = VE<U>(m_G.SZ(),m_M.Zero());}}TE <TY T,TY GRAPH,TY GROUP,TY U,TY On> IN AbstractPotentialisedDijkstra<T,GRAPH,GROUP,U,On>::AbstractPotentialisedDijkstra(GRAPH& G,GROUP M,CO T& t_start,CO U& infty,CO bool& valid,VE<U> potential,On on):PointedSet<U>(infty),m_G(G),m_M(MO(M)),m_t_start(t_start),m_valid(valid),m_potential(potential),m_on(MO(on)){ST_AS(is_invocable_r_v<bool,On,decltype(declval<GRAPH>().Edge(declval<T>()).back())>);}TE <TY T,TY GRAPH,TY On> TE <TY...Args> IN PotentialisedDijkstra<T,GRAPH,On>::PotentialisedDijkstra(GRAPH& G,CO T& t_start,Args&&... args):AbstractPotentialisedDijkstra<T,GRAPH,AdditiveGroup<>,ll,On>(G,AdditiveGroup<>(),t_start,4611686018427387904,forward<decay_t<Args>>(args)...){}TE <TY T,TY GRAPH,TY GROUP,TY U,TY On> IN CO bool& AbstractPotentialisedDijkstra<T,GRAPH,GROUP,U,On>::Valid()CO NE{RE m_valid;}TE <TY T,TY GRAPH,TY GROUP,TY U,TY On> IN CO VE<U>& AbstractPotentialisedDijkstra<T,GRAPH,GROUP,U,On>::Potential()CO NE{RE m_potential;}TE <TY T,TY GRAPH,TY GROUP,TY U,TY On> IN VO AbstractPotentialisedDijkstra<T,GRAPH,GROUP,U,On>::SetPotential(CO bool& valid,VE<U> potential){AS(int(potential.SZ())== m_G.SZ());m_valid = valid;m_potential = MO(potential);}TE <TY T,TY GRAPH,TY GROUP,TY U,TY On> tuple<bool,VE<U>> AbstractPotentialisedDijkstra<T,GRAPH,GROUP,U,On>::GetDistance(){POTENTIALISED_DIJKSTRA_BODY(GetDistance(m_t_start),value,MO(value));}TE <TY T,TY GRAPH,TY GROUP,TY U,TY On> TE <TY...Args> tuple<bool,VE<U>,VE<LI<T>>> AbstractPotentialisedDijkstra<T,GRAPH,GROUP,U,On>::GetPath(CO Args&... args){POTENTIALISED_DIJKSTRA_BODY(GetPath(m_t_start,args...),get<0>(value),MO(get<0>(value)),MO(get<1>(value)));}

TE <TY GRAPH,TY RING,TY U>CL AbstractMinimumCostFlow:PU PointedSet<U>{PU:GRAPH& m_G;RING m_R;IN AbstractMinimumCostFlow(GRAPH& G,RING R,CO U& infty);pair<U,VE<VE<tuple<inner_t<GRAPH>,U>>>> GetFlow(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final,U f);};TE <TY GRAPH,TY U>CL MinimumCostFlow:PU AbstractMinimumCostFlow<GRAPH,Ring<U>,U>{PU:IN MinimumCostFlow(GRAPH& G,CO U& one_U,CO U& infty);};
TE <TY GRAPH,TY RING,TY U> IN AbstractMinimumCostFlow<GRAPH,RING,U>::AbstractMinimumCostFlow(GRAPH& G,RING R,CO U& infty):PointedSet<U>(infty),m_G(G),m_R(MO(R)){}TE <TY GRAPH,TY U> IN MinimumCostFlow<GRAPH,U>::MinimumCostFlow(GRAPH& G,CO U& one_U,CO U& infty):AbstractMinimumCostFlow<GRAPH,Ring<U>,U>(G,Ring<U>(one_U),infty){}TE <TY GRAPH,TY RING,TY U>pair<U,VE<VE<tuple<inner_t<GRAPH>,U>>>> AbstractMinimumCostFlow<GRAPH,RING,U>::GetFlow(CO inner_t<GRAPH>& t_start,CO inner_t<GRAPH>& t_final,U f){US T = inner_t<GRAPH>;CO U& zero = m_R.Zero();CO U& infty = TH->Infty();CRI SZ = m_G.SZ();VE<VE<tuple<int,U,U,bool,int>>> rest(SZ);VE<VE<tuple<T,U>>> flow(SZ);int edge_num = 0;for(int i = 0;i < SZ;i++){auto&& ui = m_G.Enumeration(i);auto&& edge_i = m_G.Edge(ui);for(auto IT = edge_i.begin(),EN = edge_i.EN();IT != EN;IT++){CO auto&[vj,wj,fj]= *IT;AS(ui != vj && !(wj < zero)&& wj < infty && !(fj < zero)&& fj < infty);auto&& j = m_G.Enumeration_inv(vj);rest[i].push_back({j,wj,fj,false,edge_num});rest[j].push_back({i,m_R.Inverse(wj),zero,true,edge_num});flow[i].push_back({vj,0});edge_num++;}}for(int i = 0;i < SZ;i++){auto& rest_i = rest[i];sort(rest_i.begin(),rest_i.EN());}VE<tuple<int,int,int,int>> edge_pair(edge_num,{-1,-1,-1,-1});for(int i = 0;i < SZ;i++){CO auto& rest_i = rest[i];CO int SZ_i = rest_i.SZ();for(int j = 0;j < SZ_i;j++){CO auto& rest_ij = rest_i[j];auto&[i_0,j_0,i_1,j_1]= edge_pair[get<4>(rest_ij)];if(i_0 == -1){i_0 = i;j_0 = j;}else{i_1 = i;j_1 = j;}}}auto edge =[&](CO T& t)-> CO VE<tuple<int,U,U,bool,int>>&{RE rest[m_G.Enumeration_inv(t)];};auto on =[&](CO tuple<T,U,U,bool,int>& e){RE zero < get<2>(e);};auto G = m_G.GetGraph(MO(edge));AbstractPotentialisedDijkstra pd{G,m_R.AdditiveGroup(),t_start,infty,MO(on),false};auto&& i_start = m_G.Enumeration_inv(t_start);LI<T> t_finals ={t_final};U w = zero;WH(zero < f){auto[valid,weight,paths]= pd.GetPath(t_finals);AS(valid);pd.SetPotential(valid,MO(weight));auto& path = paths.front();auto IT_path = path.begin(),IT_path_prev = IT_path,EN_path = path.EN();AS(IT_path != EN_path);int i = i_start;LI<tuple<int,int,int,int>> flow_num{};U f_min = f;WH(++IT_path != EN_path){T t = *IT_path;flow_num.push_back({i,m_G.Enumeration_inv(t),-1,-1});auto&[i_curr,i_next,j_1,j_2]= flow_num.back();CO auto& rest_i = rest[i_curr];int SZ_i = rest_i.SZ();for(int j = 0;j < SZ_i;j++){CO auto&[vj,wj,fj,rj,numj]= rest_i[j];if(zero < fj && vj == t){j_1 = j;fj < f_min?f_min = fj:f_min;if(rj){i_curr = i_next;t = *IT_path_prev;}break;}}AS(j_1 != -1);auto& flow_i = flow[i_curr];SZ_i = flow_i.SZ();for(int j = 0;j < SZ_i;j++){CO auto&[vj,fj]= flow_i[j];if(vj == t){j_2 = j;break;}}AS(j_2 != -1);i_curr = i;i = i_next;IT_path_prev = IT_path;}CO U f_min_minus = m_R.Inverse(f_min);U w_diff = zero;for(auto IT = flow_num.begin(),EN = flow_num.EN();IT != EN;IT++){CO auto&[i_curr,i_next,j_1,j_2]= *IT;auto&[vj,wj,fj,rj,numj]= rest[i_curr][j_1];CO auto& edge_pair_i = edge_pair[numj];CRI j_3 = get<0>(edge_pair_i)== i_curr?get<3>(edge_pair_i):get<1>(edge_pair_i);auto& fj_inv = get<2>(rest[i_next][j_3]);auto& f_curr = get<1>(flow[rj?i_next:i_curr][j_2]);w_diff = m_R.Sum(w_diff,wj);fj = m_R.Sum(fj,f_min_minus);fj_inv = m_R.Sum(fj_inv,f_min);f_curr = m_R.Sum(f_curr,f_min);}f = m_R.Sum(f,f_min_minus);w = m_R.Sum(w,m_R.Product(f_min,w_diff));}RE{MO(w),MO(flow)};}


