#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Geometry/Graph/Algorithm/UnionFindForest/ParallelBinarySearch/a_Body.hpp"
#else
CL LinearEdge{PU:int m_SZ;int m_direction;IN LinearEdge(CRI SZ,CRI direction);IN VE<pair<int,int>> OP()(CRI t);};CL LinearGraph:PU Graph<LinearEdge>{PU:IN LinearGraph(CRI SZ,CRI direction = 1);};
IN LinearEdge::LinearEdge(CRI SZ,CRI direction):m_SZ(SZ),m_direction(direction){}IN VE<pair<int,int>> LinearEdge::OP()(CRI t){VE<pair<int,int>> AN{};if((m_direction >> 1)== 1 && t > 0){AN.push_back({t - 1,1});}if((m_direction & 1)== 1 && t + 1 < m_SZ){AN.push_back({t + 1,1});}RE AN;}IN LinearGraph::LinearGraph(CRI SZ,CRI direction):Graph<LinearEdge>(SZ,LinearEdge(SZ,direction)){}

TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>CL AbstractUnionFindForest{PU:GRAPH& m_G;ABEL_GROUP m_M;int m_root_SZ;VE<int> m_pred;VE<int> m_height;VE<U> m_w;AbstractUnionFindForest(GRAPH& G,ABEL_GROUP M);CO decltype((declval<GRAPH>().Enumeration(0)))RootOfNode(CO T&);TE <TE <TY...> TY V> VE<T> GetRoot()CO;IN U Potential(CO T& t0,CO T& t1);IN CRI SZ(CO bool& node = true)CO NE;bool Graft(CO T& t0,CO T& t1,CO U& w = U());TE <TY PATH> IN bool Graft(CO T& t0,CO PATH& t1);};TE <TY GRAPH,TY ABEL_GROUP> AbstractUnionFindForest(GRAPH& G,ABEL_GROUP M)-> AbstractUnionFindForest<inner_t<GRAPH>,GRAPH,inner_t<ABEL_GROUP>,ABEL_GROUP>;TE <TY U = int>CL UnionFindForest:PU AbstractUnionFindForest<int,LinearGraph,U,AdditiveGroup<U>>{PU:IN UnionFindForest(CRI SZ);};
TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::AbstractUnionFindForest(GRAPH& G,ABEL_GROUP M):m_G(G),m_M(MO(M)),m_root_SZ(m_G.SZ()),m_pred(m_root_SZ),m_height(m_root_SZ,1),m_w(m_root_SZ,m_M.Zero()){CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){m_pred[i]= i;}for(int i = 0;i < SZ;i++){auto&& s = m_G.Enumeration(i);for(auto& t:m_G.Edge(s)){Graft(s,t);}}}TE <TY U> IN UnionFindForest<U>::UnionFindForest(CRI SZ):AbstractUnionFindForest<int,LinearGraph,U,AdditiveGroup<U>>(LinearGraph(SZ,0),AdditiveGroup<U>()){}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>CO decltype((declval<GRAPH>().Enumeration(0)))AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::RootOfNode(CO T& t){auto&& num = m_G.Enumeration_inv(t);int& pred1 = m_pred[num];WH(true){int& pred2 = m_pred[pred1];if(pred1 == pred2){break;}m_w[num]= m_M.Sum(m_w[num],m_w[pred1]= m_M.Sum(m_w[pred1],m_w[pred2]));pred1 = pred2 = m_pred[pred2];}RE m_G.Enumeration(pred1);}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> TE <TE <TY...> TY V>VE<T> AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::GetRoot()CO{VE<T> AN{};AN.reserve(m_root_SZ);CRI SZ = m_G.SZ();for(int i = 0;i < SZ;i++){if(i == m_pred[i]){AN.push_back(m_G.Enumeration(i));}}RE AN;}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>U AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::Potential(CO T& t0,CO T& t1){CO T& root0 = RootOfNode(t0);CO T& root1 = RootOfNode(t1);AS(root0 == root1);RE m_M.Sum(m_w[m_G.Enumeration_inv(t0)],m_M.Inverse(m_w[m_G.Enumeration_inv(t1)]));}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> IN CRI AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::SZ(CO bool& node)CO NE{RE node?m_G.SZ():m_root_SZ;}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP>bool AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::Graft(CO T& t0,CO T& t1,CO U& w){CO T& root0 = RootOfNode(t0);CO T& root1 = RootOfNode(t1);if(root0 == root1){RE Potential(t0,t1)== w;}auto&& num0 = m_G.Enumeration_inv(t0);auto&& num1 = m_G.Enumeration_inv(t1);auto&& rnum0 = m_G.Enumeration_inv(root0);auto&& rnum1 = m_G.Enumeration_inv(root1);int& height0 = m_height[rnum0];CRI height1 = m_height[rnum1];CO int* p_reMOd_root;CO int* p_reMOd_node;CO int* p_kept_root;if(height0 < height1){p_reMOd_root = &rnum0;p_reMOd_node = &num0;p_kept_root = &rnum1;m_w[*p_reMOd_root]= m_M.Sum(m_w[*p_reMOd_root],m_M.Sum(m_M.Sum(m_w[num1],w),m_M.Inverse(m_w[num0])));}else{if(height0 == height1){height0++;}p_reMOd_root = &rnum1;p_reMOd_node = &num1;p_kept_root = &rnum0;m_w[*p_reMOd_root]= m_M.Sum(m_w[*p_reMOd_root],m_M.Sum(m_M.Inverse(m_M.Sum(m_w[num1],w)),m_w[num0]));}if(*p_reMOd_node != *p_reMOd_root){m_w[*p_reMOd_node]= m_M.Sum(m_w[*p_reMOd_node],m_w[*p_reMOd_root]);}m_pred[*p_reMOd_node]= m_pred[*p_reMOd_root]= *p_kept_root;m_root_SZ--;RE true;}TE <TY T,TY GRAPH,TY U,TY ABEL_GROUP> TE <TY PATH> IN bool AbstractUnionFindForest<T,GRAPH,U,ABEL_GROUP>::Graft(CO T& t0,CO PATH& t1){RE Graft(t0,get<0>(t1),get<1>(t1));}

#define INITIALISE_FOR_PBUF AbstractUnionFindForest uff{G,AdditiveGroup<int>()};auto IT = BE;
#define GRAFT_FOR_PBUF(VAL)WH(IT != EN && IT->first <= VAL){for(auto&[s,t]:IT->second){uff.Graft(s,t);}IT++;}
#define UPDATE_FOR_PBUF(VAL)auto&[s,t]= query[q];uff.RootOfNode(s)== uff.RootOfNode(t)?r[q]= VAL:++(l[q]= VAL);
TE <TY T,TY INT,TY GRAPH>VE<INT> AbstractParallelBinaryUnionFind(GRAPH& G,CO INT& v_min,CO INT& v_max,CO map<INT,VE<pair<T,T>>>& additional_edge,CO VE<pair<T,T>>& query){ST_AS(is_same_v<T,inner_t<GRAPH>>);AS(v_min <= v_max);auto BE = additional_edge.BE(),EN = additional_edge.EN();CO int Q = query.SZ();CO INT v_SZ = v_max - v_min + 1;VE l(Q,v_min),r(Q,v_max);if((Q >>(v_SZ /(Q + 1)))> 0){WH(l != r){INITIALISE_FOR_PBUF;VE m(v_SZ,VE<int>());for(int q = 0;q < Q;q++){m[((l[q]- 1 + r[q])>> 1)- v_min].push_back(q);}for(int v = v_min;v <= v_max;v++){GRAFT_FOR_PBUF(v);for(auto& q:m[v - v_min]){UPDATE_FOR_PBUF(v);}}}}else{WH(l != r){INITIALISE_FOR_PBUF;set<pair<INT,int>> m{};for(int q = 0;q < Q;q++){m.insert({(l[q]- 1 + r[q])>> 1,q});}for(auto&[m_q,q]:m){GRAFT_FOR_PBUF(m_q);UPDATE_FOR_PBUF(m_q);}}}RE r;}TE <TY T,TY INT,TY GRAPH> IN VE<INT> ParallelBinaryUnionFind(CRI SZ,CO INT& v_min,CO INT& v_max,CO map<INT,VE<pair<int,int>>>& additional_edge,CO VE<pair<int,int>>& query){RE AbstractParallelBinaryUnionFind(LinearGraph(SZ,0),v_min,v_max,additional_edge,query);}
#endif

