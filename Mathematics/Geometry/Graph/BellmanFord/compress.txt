// ../compress.txt‚ðæ‚É“\‚éB

#define BELLMAN_FORD_BODY(INITIALISE_PREV,SET_PREV)CO U& zero = m_M.Zero();CO U& infty = TH->Infty();AS(zero < infty);CRI SZ = m_G.SZ();auto&& i_start = m_G.Enumeration_inv(t_start);AS(0 <= i_start && i_start < SZ);VE<bool> found(SZ);VE<U> weight(SZ,infty);found[i_start]= true;weight[i_start]= 0;INITIALISE_PREV;for(int LE = 0;LE < SZ;LE++){for(int i = 0;i < SZ;i++){if(found[i]){CO U& weight_i = weight[i];AS(weight_i != infty);auto&& edge_i = m_G.Edge(m_G.Enumeration(i));for(auto IT = edge_i.BE(),EN = edge_i.EN();IT != EN;IT++){auto&& j = m_G.Enumeration_inv(IT->first);CO U& edge_ij = IT->second;U temp = m_M.Sum(weight_i,edge_ij);U& weight_j = weight[j];if(weight_j > temp){found[j]= true;weight_j = MO(temp);SET_PREV;}}}}}bool valid = true;for(int i = 0;i < SZ && valid;i++){if(found[i]){CO U& weight_i = weight[i];auto&& edge_i = m_G.Edge(m_G.Enumeration(i));for(auto IT = edge_i.begin(),EN = edge_i.EN();IT != EN;IT++){auto&& j = m_G.Enumeration_inv(IT->first);CO U& edge_ij = IT->second;U& weight_j = weight[j];CO U temp = m_M.Sum(weight_i,edge_ij);if(weight_j > temp){valid = false;break;}}}}
TE <TY GRAPH,TY MONOID,TY U>CL AbstractBellmanFord:PU PointedSet<U>{PU:GRAPH& m_G;MONOID m_M;IN AbstractBellmanFord(GRAPH& G,MONOID M,CO U& infty);tuple<bool,VE<U>> GetDistance(CO inner_t<GRAPH>& t_start,CO bool& dummy = true);TE <TE <TY...> TY V> tuple<bool,VE<U>,VE<LI<inner_t<GRAPH>>>> GetPath(CO inner_t<GRAPH>& t_start,CO V<inner_t<GRAPH>>& t_finals,CO bool& dummy = true);tuple<bool,VE<U>,VE<LI<inner_t<GRAPH>>>> GetPath(CO inner_t<GRAPH>& t_start,CO bool& dummy);};TE <TY GRAPH>CL BellmanFord:PU AbstractBellmanFord<GRAPH,AdditiveMonoid<>,ll>{PU:IN BellmanFord(GRAPH& G);};
TE <TY GRAPH,TY MONOID,TY U> IN AbstractBellmanFord<GRAPH,MONOID,U>::AbstractBellmanFord(GRAPH& G,MONOID M,CO U& infty):PointedSet<U>(infty),m_G(G),m_M(MO(M)){ST_AS(! is_same_v<U,int>);}TE <TY GRAPH> IN BellmanFord<GRAPH>::BellmanFord(GRAPH& G):AbstractBellmanFord<GRAPH,AdditiveMonoid<>,ll>(G,AdditiveMonoid<>(),4611686018427387904){}TE <TY GRAPH,TY MONOID,TY U>tuple<bool,VE<U>> AbstractBellmanFord<GRAPH,MONOID,U>::GetDistance(CO inner_t<GRAPH>& t_start,CO bool& dummy){BELLMAN_FORD_BODY(,);RE{valid,MO(weight)};}TE <TY GRAPH,TY MONOID,TY U> TE <TE <TY...> TY V>tuple<bool,VE<U>,VE<LI<inner_t<GRAPH>>>> AbstractBellmanFord<GRAPH,MONOID,U>::GetPath(CO inner_t<GRAPH>& t_start,CO V<inner_t<GRAPH>>& t_finals,CO bool& dummy){BELLMAN_FORD_BODY(VE<int> prev(SZ),prev[j]= i);VE<LI<inner_t<GRAPH>>> path{};if(valid){CO int path_SZ = t_finals.SZ();path.reserve(path_SZ);for(auto IT = t_finals.begin(),EN = t_finals.EN();IT != EN;IT++){LI<inner_t<GRAPH>> path_j{};CO inner_t<GRAPH>& t_final = *IT;path_j.push_back(t_final);int i = m_G.Enumeration_inv(t_final);if(found[i]){WH(i != i_start){i = prev[i];path_j.push_front(m_G.Enumeration(i));}}path.push_back(path_j);}}RE{valid,MO(weight),MO(path)};}TE <TY GRAPH,TY MONOID,TY U>tuple<bool,VE<U>,VE<LI<inner_t<GRAPH>>>> AbstractBellmanFord<GRAPH,MONOID,U>::GetPath(CO inner_t<GRAPH>& t_start,CO bool& dummy){CRI SZ = m_G.SZ();VE<inner_t<GRAPH>> t_finals(SZ);for(int i = 0;i < SZ;i++){t_finals[i]= i;}RE GetPath(t_start,t_finals);}
