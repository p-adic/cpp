#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/Negative/a_Body.hpp"
#else
TE <TY U,TY COMM_MONOID>U AbstractValueSumBound(COMM_MONOID M,CO VE<U>& value){CO U& one = M.One();U AN = one;for(auto& v:value){one < v?AN = M.Product(MO(AN),v):AN;}RE AN;}TE <TY INT> IN INT ValueSumBound(CO VE<INT>& value){RE AbstractValueSumBound(AdditiveMonoid<INT>(),value);}

TE <TY U1,TY COMM_MONOID1,TY U2,TY COMM_MONOID2>pair<U1,U2> AbstractNegativeBoundedValueSumKnapsack(COMM_MONOID1 M1,COMM_MONOID2 M2,CO VE<U1>& value,CO U1& value_sum_bound,CO VE<U2>& cost,CO U2& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);CO U1& one1 = M1.One();AS(!(value_sum_bound < one1));CO U2& one2 = M2.One();AS(!(cost_sum_bound < one2));pair<U1,U2> AN ={one1,one2};if(N == 1){if(!(cost_sum_bound < cost[0])&& !(value_sum_bound < value[0])){AN ={value[0],cost[0]};}}else if(N > 1){CO int N_half_left = N >> 1;CO int N_half_right = N - N_half_left;unordered_map<int,int> valuation{};for(int i = 0;i < N_half_right;i++){valuation[1<<i]= i;}CO int PW_left = 1 << N_half_left;VE<pair<U2,U1>> sum_left(PW_left,{one2,one1});for(int s = 1;s < PW_left;s++){CO int lsb = s & -s;CRI i = valuation[lsb];auto& sum_left_s = sum_left[s];auto& sum_left_s_minus = sum_left[s ^ lsb];sum_left_s.first = M2.Product(sum_left_s_minus.first,cost[i]);sum_left_s.second = M1.Product(sum_left_s_minus.second,value[i]);}CO int PW_right = 1 << N_half_right;VE<pair<U2,U1>> sum_right(PW_right,{one2,one1});for(int s = 1;s < PW_right;s++){CO int lsb = s & -s;CO int i = N_half_left + valuation[lsb];auto& sum_right_s = sum_right[s];auto& sum_right_s_minus = sum_right[s ^ lsb];sum_right_s.first = M2.Product(sum_right_s_minus.first,cost[i]);sum_right_s.second = M1.Product(sum_right_s_minus.second,value[i]);}sort(sum_right.BE(),sum_right.EN());for(int s = 1;s < PW_right;s++){sum_right[s].second = max(sum_right[s].second,sum_right[s-1].second);}for(int s = 0;s < PW_left;s++){auto& sum_left_s = sum_left[s];if(!(cost_sum_bound < sum_left_s.first)&& !(value_sum_bound < sum_left_s.second)){BS2(t,0,PW_right - 1,!(value_sum_bound < M1.Product(sum_left_s.second,sum_right[t].second))&& !(cost_sum_bound < M2.Product(sum_left_s.first,sum_right[t].first))?0:1,0);if(!(M1.Product(sum_left_s.second,sum_right[t].second)< AN.first)){auto& value_max = sum_right[t].second;BS1(u,0,t,sum_right[u].second,value_max);AS(sum_right[u].second == value_max);pair<U1,U2> temp ={M1.Product(sum_left_s.second,value_max),M2.Product(sum_left_s.first,sum_right[u].first)};AN.first < temp.first ||(AN.first == temp.first && temp.second < AN.second)?AN = MO(temp):AN;}}}}RE AN;}TE <TY INT1,TY INT2> IN pair<INT1,INT2> NegativeBoundedValueSumKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractNegativeBoundedValueSumKnapsack(AdditiveMonoid<INT1>(),AdditiveMonoid<INT2>(),value,value_sum_bound,cost,cost_sum_bound);}
#endif
