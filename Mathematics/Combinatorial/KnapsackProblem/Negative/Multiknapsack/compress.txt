#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Combinatorial/KnapsackProblem/Negative/Multiknapsack/a_Body.hpp"
#else
TE <TY U,TY COMM_MONOID>U AbstractValueSumBound(COMM_MONOID M,CO VE<U>& value){CO U& one = M.One();U AN = one;for(auto& v:value){one < v?AN = M.Product(MO(AN),v):AN;}RE AN;}TE <TY INT> IN INT ValueSumBound(CO VE<INT>& value){RE AbstractValueSumBound(AdditiveMonoid<INT>(),value);}

TE <TY U1,TY COMM_MONOID1,TY U2,TY COMM_MONOID2>pair<U1,U2> AbstractNegativeBoundedValueSumKnapsack(COMM_MONOID1 M1,COMM_MONOID2 M2,CO VE<U1>& value,CO U1& value_sum_bound,CO VE<U2>& cost,CO U2& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N);CO U1& one1 = M1.One();AS(!(value_sum_bound < one1));CO U2& one2 = M2.One();AS(!(cost_sum_bound < one2));pair<U1,U2> AN ={one1,one2};if(N == 1){if(!(cost_sum_bound < cost[0])&& !(value_sum_bound < value[0])){AN ={value[0],cost[0]};}}else if(N > 1){CO int N_half_left = N >> 1;CO int N_half_right = N - N_half_left;unordered_map<int,int> valuation{};for(int i = 0;i < N_half_right;i++){valuation[1<<i]= i;}CO int PW_left = 1 << N_half_left;VE<pair<U2,U1>> sum_left(PW_left,{one2,one1});for(int s = 1;s < PW_left;s++){CO int lsb = s & -s;CRI i = valuation[lsb];auto& sum_left_s = sum_left[s];auto& sum_left_s_minus = sum_left[s ^ lsb];sum_left_s.first = M2.Product(sum_left_s_minus.first,cost[i]);sum_left_s.second = M1.Product(sum_left_s_minus.second,value[i]);}CO int PW_right = 1 << N_half_right;VE<pair<U2,U1>> sum_right(PW_right,{one2,one1});for(int s = 1;s < PW_right;s++){CO int lsb = s & -s;CO int i = N_half_left + valuation[lsb];auto& sum_right_s = sum_right[s];auto& sum_right_s_minus = sum_right[s ^ lsb];sum_right_s.first = M2.Product(sum_right_s_minus.first,cost[i]);sum_right_s.second = M1.Product(sum_right_s_minus.second,value[i]);}sort(sum_right.BE(),sum_right.EN());for(int s = 1;s < PW_right;s++){sum_right[s].second = max(sum_right[s].second,sum_right[s-1].second);}for(int s = 0;s < PW_left;s++){auto& sum_left_s = sum_left[s];if(!(cost_sum_bound < sum_left_s.first)&& !(value_sum_bound < sum_left_s.second)){BS2(t,0,PW_right - 1,!(value_sum_bound < M1.Product(sum_left_s.second,sum_right[t].second))&& !(cost_sum_bound < M2.Product(sum_left_s.first,sum_right[t].first))?0:1,0);if(!(M1.Product(sum_left_s.second,sum_right[t].second)< AN.first)){auto& value_max = sum_right[t].second;BS1(u,0,t,sum_right[u].second,value_max);AS(sum_right[u].second == value_max);pair<U1,U2> temp ={M1.Product(sum_left_s.second,value_max),M2.Product(sum_left_s.first,sum_right[u].first)};AN.first < temp.first ||(AN.first == temp.first && temp.second < AN.second)?AN = MO(temp):AN;}}}}RE AN;}TE <TY INT1,TY INT2> IN pair<INT1,INT2> NegativeBoundedValueSumKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractNegativeBoundedValueSumKnapsack(AdditiveMonoid<INT1>(),AdditiveMonoid<INT2>(),value,value_sum_bound,cost,cost_sum_bound);}

TE <TY U1,TY COMM_MONOID1,TY U2,TY COMM_MONOID2>VE<pair<U1,U2>> AbstractNegativeBitExhausiveSeachForKnapsack(COMM_MONOID1 M1,COMM_MONOID2 M2,CRI N,CO VE<U1>& value,CO VE<U2>& cost){int PW = 1 << N;VE<pair<U1,U2>> product(PW,{M1.One(),M2.One()});for(int i = 0;i < N;i++){int p = 1 << i;for(int j = p;j < PW;(++j)|= p){auto&[v,w]= product[j ^ p];product[j]={M1.Product(v,value[i]),M2.Product(w,cost[i])};}}RE product;};TE <TY U1,TY U2>VE<pair<U1,U2>> AbstractNegativeFastZetaTransformForKnapsack(CRI N,CO U1& one1,VE<pair<U1,U2>> product,CO U1& value_sum_bound,CO U2& cost_sum_bound){for(auto&[v,w]:product){value_sum_bound < v || cost_sum_bound < w?v = one1:v;}CO int PW = 1 << N;int p = 1;for(int i = 0;i < N;i++,p <<= 1){int j = p;WH(j < PW){auto&[v_j,w_j]= product[j];auto&[v_j_prev,w_j_prev]= product[j ^ p];v_j < v_j_prev?(v_j = v_j_prev,w_j = w_j_prev):v_j == v_j_prev && w_j_prev < w_j?w_j = w_j_prev:w_j;(++j)|= p;}}RE product;}TE <TY U1,TY COMM_MONOID1,TY U2,TY COMM_MONOID2>VE<pair<U1,U2>> AbstractNegativeBoundedValueSumSubsetwiseKnapsack(COMM_MONOID1 M1,COMM_MONOID2 M2,CO VE<U1>& value,CO U1& value_sum_bound,CO VE<U2>& cost,CO U2& cost_sum_bound){CO int N = value.SZ();AS(int(cost.SZ())== N && N < 30);CO U1 one1 = M1.One();auto product = AbstractNegativeBitExhausiveSeachForKnapsack(MO(M1),MO(M2),N,value,cost);RE AbstractNegativeFastZetaTransformForKnapsack(N,one1,MO(product),value_sum_bound,cost_sum_bound);}TE <TY INT1,TY INT2> IN VE<pair<INT1,INT2>> NegativeBoundedValueSumSubsetwiseKnapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO INT2& cost_sum_bound){RE AbstractNegativeBoundedValueSumSubsetwiseKnapsack(AdditiveMonoid<INT1>(),AdditiveMonoid<INT2>(),value,value_sum_bound,cost,cost_sum_bound);}

TE <TY U1,TY COMM_MONOID1,TY U2,TY COMM_MONOID2>pair<U1,U2> AbstractNegativeBoundedValueSumMultiknapsack(COMM_MONOID1 M1,COMM_MONOID2 M2,CO VE<U1>& value,CO U1& value_sum_bound,CO VE<U2>& cost,CO VE<U2>& cost_sum_bound){CO int K = cost_sum_bound.SZ();if(K == 0){RE{M1.One(),M2.One()};}else if(K == 1){RE AbstractNegativeBoundedValueSumKnapsack(MO(M1),MO(M2),value,value_sum_bound,cost,cost_sum_bound[0]);}CO int N = value.SZ();AS(int(cost.SZ())== N && N < 30);auto total_product = AbstractNegativeBitExhausiveSeachForKnapsack(M1,M2,N,value,cost);VE<VE<pair<U1,U2>>> product(K);for(int k = 0;k < K;k++){product[k]= AbstractNegativeFastZetaTransformForKnapsack(N,M1.One(),total_product,value_sum_bound,cost_sum_bound[k]);}CO int ambient =(1 << N)- 1;VE<int> S(K,ambient);S[0]= 0;CRI S1 = S[1];auto[AN1,AN2]= product[0][ambient];WH(S1 > 0){auto[temp1,temp2]= product[0][ambient ^ S1];for(int k = 1;k < K;k++){auto&[v,w]= product[k][S[k-1]^ S[k]];temp1 = M1.Product(MO(temp1),v);temp2 = M2.Product(MO(temp2),w);}value_sum_bound < temp1 || temp1 < AN1 ||(AN1 == temp1 && !(temp2 < AN2))?AN2:AN1 < temp1?(AN1 = MO(temp1),AN2 = MO(temp2)):AN2 = MO(temp2);int layer = K - 1;WH(S[layer]== 0){layer--;}auto& s = --S[layer];for(int i = layer + 1;i < K;i++){S[i]= s;}}RE{MO(AN1),MO(AN2)};}TE <TY INT1,TY INT2> IN pair<INT1,INT2> NegativeBoundedValueSumMultiknapsack(CO VE<INT1>& value,CO INT1& value_sum_bound,CO VE<INT2>& cost,CO VE<INT2>& cost_sum_bound){RE AbstractNegativeBoundedValueSumMultiknapsack(AdditiveMonoid<INT1>(),AdditiveMonoid<INT2>(),value,value_sum_bound,cost,cost_sum_bound);}
#endif

