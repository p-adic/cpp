#ifdef DEBUG
  #include "c:/Users/user/Documents/Programming/Mathematics/Utility/String/RollingHash/Shift/BiModule/a_Body.hpp"
#else
IN int GCD(){RE 0;}TE <TY INT1,TY...INT2>INT1 GCD(INT1 b_0,INT2... args){b_0 < 0?b_0 = -b_0:b_0;INT1 b_1 = GCD(MO(args)...);WH(b_1 != 0){swap(b_0 %= b_1,b_1);}RE MO(b_0);}

TE <TY MODINT,TY INT = int,TY CODE = tuple<MODINT,MODINT,INT>>CL RollingHash{PU:INT m_SZ;MODINT m_r;MODINT m_r_inv;VE<MODINT> m_r_pw;IN RollingHash();IN RollingHash(MODINT r);IN CO MODINT& r()CO NE;IN CO MODINT& r_inv()CO NE;IN CO VE<MODINT>& r_pw()CO NE;TE <TY STR> IN CODE Encode(CO STR& s,CO bool& reversed = false);TE <TY STR> IN VE<CODE> CumulativeEncode(CO STR& s,CO bool& reversed = false);TE <TY STR> IN VE<CODE> PointwiseEncode(CO STR& s,CO bool& reversed = false);TE <TY STR> IN VE<CODE> FixedLengthEncode(CO STR& s,CRI le,CO bool& reversed = false);TE <TY CHAR> IN CODE Replace(CODE code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next)CO;TE <TY CHAR> IN CODE PopFront(CODE code,CO CHAR& c_prev)CO;TE <TY CHAR> IN CODE PopBack(CODE code,CO CHAR& c_prev)CO;TE <TY STR> IN INT CountContain(CO STR& s,CO CODE& code,CO bool& reversed = false);ST IN CODE Concatenate(CODE code0,CO CODE& code1);ST IN CODE Fold(CODE code,INT n);MODINT GetRand();VO CheckSize(CO INT& SZ);VI MODINT Twist(CRL c);};
TE <TY MODINT,TY INT,TY CODE> IN RollingHash<MODINT,INT,CODE>::RollingHash():RollingHash(GetRand()){}TE <TY MODINT,TY INT,TY CODE> IN RollingHash<MODINT,INT,CODE>::RollingHash(MODINT r):m_SZ(1),m_r(MO(r)),m_r_inv(m_r),m_r_pw{1}{m_r_inv.Invert();}TE <TY MODINT,TY INT,TY CODE> IN CO MODINT& RollingHash<MODINT,INT,CODE>::r()CO NE{RE m_r;}TE <TY MODINT,TY INT,TY CODE> IN CO MODINT& RollingHash<MODINT,INT,CODE>::r_inv()CO NE{RE m_r_inv;}TE <TY MODINT,TY INT,TY CODE> IN CO VE<MODINT>& RollingHash<MODINT,INT,CODE>::r_pw()CO NE{RE m_r_pw;}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN CODE RollingHash<MODINT,INT,CODE>::Encode(CO STR& s,CO bool& reversed){CO int SZ = s.SZ();CheckSize(SZ + 1);MODINT AN = 0;for(int i = 0;i < SZ;i++){AN += Twist(s[reversed?SZ - 1 - i:i])* m_r_pw[i];}RE{AN,m_r_pw[SZ],SZ};}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN VE<CODE> RollingHash<MODINT,INT,CODE>::CumulativeEncode(CO STR& s,CO bool& reversed){CO int SZ = s.SZ();CheckSize(SZ + 1);VE<CODE> AN(SZ + 1);for(int i = 0;i < SZ;i++){AN[i+1]= Concatenate(AN[i],{Twist(s[reversed?SZ - 1 - i:i])* m_r_pw[i],m_r,1});}RE AN;}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN VE<CODE> RollingHash<MODINT,INT,CODE>::PointwiseEncode(CO STR& s,CO bool& reversed){CO int SZ = s.SZ();CheckSize(SZ + 1);VE<CODE> AN(SZ);for(int i = 0;i < SZ;i++){AN[i]={Twist(s[reversed?SZ - 1 - i:i]),m_r,1};}RE AN;}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN VE<CODE> RollingHash<MODINT,INT,CODE>::FixedLengthEncode(CO STR& s,CRI le,CO bool& reversed){CO int SZ = s.SZ();VE<CODE> AN{};if(le <= SZ){CheckSize(le + 1);AN.resize(SZ - le + 1,{MODINT{},m_r_pw[le],1});for(int i = 0;i < le;i++){get<0>(AN[0])+= Twist(s[reversed?SZ - 1 - i:i])* m_r_pw[i];}CO int SZ_shifted = SZ - le;for(int i = 1;i <= SZ_shifted;i++){get<0>(AN[i])=(get<0>(AN[i-1])- e(s[reversed?SZ - i:i - 1]))* m_r_inv + e(s[reversed?SZ - i - le:i - 1 + le])* m_r_pw[le-1];}}RE AN;}TE <TY MODINT,TY INT,TY CODE> TE <TY CHAR> IN CODE RollingHash<MODINT,INT,CODE>::Replace(CODE code,CO INT& i,CO CHAR& c_prev,CO CHAR& c_next)CO{auto&[h,p,s]= code;AS(i < s);h +=(Twist(c_next)-= Twist(c_prev))*=(i < m_SZ?m_r_pw[i]:R_Power(m_r,i));RE MO(code);}TE <TY MODINT,TY INT,TY CODE> TE <TY CHAR> IN CODE RollingHash<MODINT,INT,CODE>::PopFront(CODE code,CO CHAR& c_prev)CO{auto&[h,p,s]= code;AS(s-- > 0);h -= Twist(c_prev)*(s < m_SZ?m_r_pw[s]:R_Power(m_r,s));r *= m_r_inv;RE MO(code);}TE <TY MODINT,TY INT,TY CODE> TE <TY CHAR> IN CODE RollingHash<MODINT,INT,CODE>::PopBack(CODE code,CO CHAR& c_prev)CO{auto&[h,p,s]= code;AS(s-- > 0);(h -= Twist(c_prev)* m_r_pw[0])*= m_r_inv;r *= m_r_inv;RE MO(code);}TE <TY MODINT,TY INT,TY CODE> TE <TY STR> IN INT RollingHash<MODINT,INT,CODE>::CountContain(CO STR& s,CO CODE& code,CO bool& reversed){CO INT SZ0 = s.SZ();CheckSize(SZ0);CO MODINT& n = get<0>(code);CO INT& SZ1 = get<2>(code);if(SZ1 == 0){RE 1;}CheckSize(SZ1);CO MODINT& r_pw = m_r_pw[SZ1 - 1];INT AN = 0;MODINT temp = 0;for(INT i = 0;i < SZ0;i++){(i < SZ1?temp += e(s[reversed?SZ0 - 1 - i:i])* m_r_pw[i]:((temp -= Twist(s[reversed?SZ0 + SZ1 - 1 - i:i - SZ1]))*= m_r_inv)+= Twist(s[reversed?SZ0 - 1 - i:i])* r_pw)== n?++AN:AN;}RE AN;}TE <TY MODINT,TY INT,TY CODE> IN CODE RollingHash<MODINT,INT,CODE>::Concatenate(CODE code0,CO CODE& code1){auto&[h,p,s]= code0;h += get<0>(code1)* p;p *= get<1>(code1);s += get<2>(code1);RE MO(code0);}TE <TY MODINT,TY INT,TY CODE> IN CODE RollingHash<MODINT,INT,CODE>::Fold(CODE code,INT n){AS(n >= 0);CODE AN{0,1,0};auto&[h,p,s]= code;WH(n > 0){(n & 1)== 1?AN = Concatenate(MO(AN),code):AN;h *= p + 1;p *= p;s += s;n >>= 1;}RE AN;}TE <TY MODINT,TY INT,TY CODE> MODINT RollingHash<MODINT,INT,CODE>::GetRand(){RE::GetRand(((MODINT{}- 1)/ 11).RP(),(MODINT{}- 1).RP());}TE <TY MODINT,TY INT,TY CODE> VO RollingHash<MODINT,INT,CODE>::CheckSize(CO INT& SZ){WH(m_SZ < SZ){m_r_pw.push_back(m_r_pw[m_SZ++ - 1]* m_r);}}TE <TY MODINT,TY INT,TY CODE> MODINT RollingHash<MODINT,INT,CODE>::Twist(CRL c){RE MODINT(c);}

TE <TY MODINT = Mod<999309403>,TY INT = int,TY CODE = tuple<MODINT,MODINT,INT>>CL ShiftableRollingHash:PU RollingHash<MODINT,INT,CODE>{PU:MODINT m_pw[26];IN ShiftableRollingHash();IN CODE Shift(CO Mod<26>& shift,CODE c)CO;MODINT Twist(CRL c);ST MODINT GetPrimitiveRoot();};
TE <TY MODINT,TY INT,TY CODE> IN ShiftableRollingHash<MODINT,INT,CODE>::ShiftableRollingHash():RollingHash<MODINT,INT,CODE>(GetPrimitiveRoot()),m_pw{MODINT::DeRP(1)}{CE CO decltype(MODINT::GetModulo())P = MODINT::GetModulo();ST_AS(P == 999309403 || P == 999300121 || P == 999300017);m_pw[1]= MODINT::DeRP(P == 999309403?1102168:P == 999300121?75873362:31458519);for(int i = 2;i < 26;i++){m_pw[i]= m_pw[i-1]* m_pw[1];}}TE <TY MODINT,TY INT,TY CODE> IN CODE ShiftableRollingHash<MODINT,INT,CODE>::Shift(CO Mod<26>& shift,CODE c)CO{get<0>(c)*= m_pw[shift.RP()];RE MO(c);}TE <TY MODINT,TY INT,TY CODE> MODINT ShiftableRollingHash<MODINT,INT,CODE>::Twist(CRL c){AS('A' <= c && c <= 'z');RE m_pw[c -(c < 'a'?'A':'a')];}TE <TY MODINT,TY INT,TY CODE>MODINT ShiftableRollingHash<MODINT,INT,CODE>::GetPrimitiveRoot(){CE CO decltype(MODINT::GetModulo())P = MODINT::GetModulo();CE CO MODINT pr = MODINT::DeRP(P == 999309403?2:P == 999300121?22:5);int EX = GetRand(1,P - 1);RE Power(pr,MO(EX /= GCD(EX,P - 1)));}

TE <TY MODINT = Mod<999309403>,TY INT = int,TY CODE = tuple<MODINT,MODINT,INT>>CL ShiftableRollingHashBiModule:PU PointedSet<CODE>,VI PU VirtualGroup<CODE>,VI PU VirtualBiModule<Mod<26>,int,CODE>{PU:CO ShiftableRollingHash<MODINT,INT,CODE>* m_p_srh;IN ShiftableRollingHashBiModule(CO ShiftableRollingHash<MODINT,INT,CODE>& srh);IN CODE Product(CODE code0,CO CODE& code1);IN CODE Transfer(CO CODE& code);IN CODE LAction(CO Mod<26>& l,CODE code);IN CODE RAction(CODE code,CRI r);};
TE <TY MODINT,TY INT,TY CODE> IN ShiftableRollingHashBiModule<MODINT,INT,CODE>::ShiftableRollingHashBiModule(CO ShiftableRollingHash<MODINT,INT,CODE>& srh):PointedSet<CODE>({0,1,0}),m_p_srh{&srh}{ST_AS(is_same_v<CODE,tuple<MODINT,MODINT,INT>>);}TE <TY MODINT,TY INT,TY CODE> IN CODE ShiftableRollingHashBiModule<MODINT,INT,CODE>::Product(CODE code0,CO CODE& code1){RE ShiftableRollingHash<MODINT,INT>::Concatenate(MO(code0),code1);}TE <TY MODINT,TY INT,TY CODE> IN CODE ShiftableRollingHashBiModule<MODINT,INT,CODE>::Transfer(CO CODE& code){MODINT p = 1 / get<1>(code);RE{- get<0>(code)* p,p,-get<2>(code)};}TE <TY MODINT,TY INT,TY CODE> IN CODE ShiftableRollingHashBiModule<MODINT,INT,CODE>::LAction(CO Mod<26>& l,CODE code){RE m_p_srh->Shift(l,MO(code));}TE <TY MODINT,TY INT,TY CODE> IN CODE ShiftableRollingHashBiModule<MODINT,INT,CODE>::RAction(CODE code,CRI r){RE ShiftableRollingHash<MODINT,INT>::Fold(MO(code),r);}
#endif
